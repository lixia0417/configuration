1.调用connect()是要进行异步连接，不阻塞，不管连接成功或者失败的时候select都会进行通知,这和连接超时没有关系，连接超时那个只是启动一个timer任务，超时时间到的时候进入提交重连任务。
但是如果连接成功了。那么会取消掉这个timer，连接失败时也会取消这个timer，并提前提交重连任务，一旦提交重连任务，整个重连就一直持续存在。此时如果从来就没有连通过，那么此时是不会进行发送心跳包的。
只是一直试着重连.
2.如果没有进行awaitReadyInterrupt调用，当然也没有由此引起的异常返回。那么如果调用invokeToGroup的时候还没有可用的连接，那么就会返回一个BooleanAckCommand命令，表示没有可用的连接.
调用awaitReadyInterrupt的作用其实就是等待可用连接数到达设定的连接数量(默认情况下为1)，
3.如果有连接可用并调用invokeToGroup等待结果的时候是调用了coundownLatch.await(timeout)进入等待了,当结果返回的时候await就会返回true并往下执行返回结果。如果时间到，那么await返回false
，并抛出TimeoutException，这样只能在方法外面捕获异常并返回异常结果,注意抛出异常时该方法里面没有提交重连任务，重连任务的提交交由心跳进行，发送心跳命令的时候会添加一个SingleRequestCallBackRunner的超时
任务，当5s时间到而没有任何心跳应答的时候执行SingleRequestCallBackRunner的run方法进而执行HeartBeatListener的onResponse方法，当连续三次心跳没有响应就会执行innerCloseConnection方法，
在该方法中会关闭连接，并把连接设置成允许重连，当连接真正被关闭时，onSessionClosed方法被调用，并且因为此时允许重连，所以会提交重连任务,一旦到达这一步，那么重连尝试会一直进行下去.
4.CommandFactory的createBooleanAckCommand方法是当有异常等情况时，比如心跳超时执行SingleRequestCallBackRunner的run方法时会创建一个BooleanAckCommand对象作为参数传给
HeartBeatListener的onResponse方法。
5.CodecFactory里面的Encoder就是对发送的消息(心跳消息和业务消息)进行解码也就是转成二进制流的。至于怎么转是由你自己决定的。home代码中的逻辑现在是每个发送的消息实现一个encode方法，
然后调用每个消息的encode方法来转成二进制流.
6.CodecFactory里面的Decoder是对收到的响应(即服务器有消息返回)(心跳响应和业务响应)进行编码，也就是转成java对象。在该方法中，你需要判断是否接收到了完整的响应的包，在确认收到完整的响应包之后你可以转成任何你想要的java对象。
在home中是转成了各种Response对象，这些你转成的java对象就是就是调用invokeToGroup返回的结果.注意：这些情况下不经过Decode编码：心跳超时时，直接返回BooleanAckCommand超时响应消息，
此时如果阻塞在getResult中等待结果的话，那么此时就可以拿到结果了. 不管有没有经过Decode编码，都要调用了onResponse方法，onResponse方法一旦调用那么意味着结果已经出来了。即getResult方法
就不会再阻塞，此后还有调用listener的onResponse方法来通知相应的监听器告知结果已经返回。
7.心跳的监听器对返回的结果（不管是正常结果即home中的HeartBeatResponse结果还是心跳异常的timeOutResponse结果）都会触发HeartBeatListener的监听器，触发器里面有判断该消息是
正常消息还是异常（超时）消息的判断，对于异常消息,他会进行计数，数量达到3次的话，就调用innerCloseConnection关闭连接，并在onSessionClosed方法中提交重连任务.然后重连尝试会一直进行下去.
注意心跳的目的并不是获取结果值，而是为了调用HeartBeatListener，心跳处理那里并没有处理返回值（即忽略返回值）,超时时返回的异常消息是使用createTimeoutCommand创建的BooleanAckCommand类型的超时消息.
8.对于SingleRequestCallBack来说。无论是心跳的时候调用send还是正常发送消息的时候调用invokeToGroup，都会新建一个SingleRequestCallBack，然后往这个新建的SingleRequestCallBack的writeFutureMap中
添加这个connection->Future的对应，这里关键要认识到的是每次发消息的时候都新建这个SingleRequestCallBack，所以对SingleRequestCallBack来说，其实不需要用集合map来存放connection->Future，分开两个字段
一个存放Connnection，一个存放Future即可.
9.请求消息和响应消息的opaque是一致的很重要，框架里面是通过该opaque拿出发出消息时注册的那个callback的，也就是说对该消息的响应必须具有和发送的请求一样的opaque才可能拿出发送时
注册的那个callback。这其实就相当于要求服务器在返回响应（这里默认gecko作为客户端）的时候，把请求中的那个opaque复制出来放置到对应的响应消息中，只有这样才可能请求和响应的opaque是
对应一致的.
10.gecko关闭的时候其实执行的操作是添加一个毒丸消息到写队列中，等待写到该消息时，就会真正关闭socket。在真正关闭socket之后他还判断是否要重连，如果要重连的话，会提交重连任务，进入重连流程中.
